// app/api/webhook/stripe/route.ts (Ê≠£„Åó„ÅÑ‰øÆÊ≠£Áâà - „Éà„É©„Ç§„Ç¢„É´„É¶„Éº„Ç∂„Éº„ÇÇÊ≠£Â∏∏Âá¶ÁêÜ)
export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';
import { logger } from '@/lib/utils/logger';
import {
  stripe,
  getPlanInfoByPriceId,
  getStripeInstance,
  getPaymentLinkByPlan,
} from '@/lib/stripe';
import { prisma } from '@/lib/prisma';
import Stripe from 'stripe';

// üöÄ Webhook„Éè„É≥„Éâ„É©„Éº - È´òÈÄü„É¨„Çπ„Éù„É≥„Çπ + Ë≤°ÂãôÁÆ°ÁêÜ + „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´ÂØæÂøú
export async function POST(req: NextRequest) {
  const startTime = Date.now();

  try {
    logger.info('Stripe Webhook received at:', new Date().toISOString());

    const body = await req.text();
    const signature = req.headers.get('stripe-signature') as string;

    if (!process.env.STRIPE_WEBHOOK_SECRET) {
      logger.error('STRIPE_WEBHOOK_SECRET not defined');
      return new Response('Webhook secret not defined', { status: 200 });
    }

    if (!signature) {
      logger.error('No Stripe signature');
      return new Response('No signature', { status: 200 });
    }

    let event: Stripe.Event;
    try {
      if (!stripe) {
        throw new Error('Stripe client not initialized');
      }

      event = stripe.webhooks.constructEvent(body, signature, process.env.STRIPE_WEBHOOK_SECRET);
      logger.info('Signature verified for event:', event.type);
    } catch (error) {
      logger.error('Signature verification failed:', error);
      return new Response('Invalid signature', { status: 400 });
    }

    // üöÄ ÈáçË¶ÅÔºöÂç≥Â∫ß„Å´200„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åô
    const responseTime = Date.now() - startTime;
    logger.info(`Quick response sent in ${responseTime}ms for event: ${event.type}`);

    // üìÑ ÈùûÂêåÊúü„Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂá¶ÁêÜ„ÇíÂÆüË°åÔºà„É¨„Çπ„Éù„É≥„ÇπÂæåÔºâ
    setImmediate(() => {
      processWebhookEventAsync(event).catch((error) => {
        logger.error('Background webhook processing failed:', error);
      });
    });

    // Stripe„Å´Âç≥Â∫ß„Å´„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åô
    return NextResponse.json(
      {
        received: true,
        eventType: event.type,
        responseTime: responseTime,
        status: 'processing_async',
        financialIntegration: true,
        oneTapSealSupport: true,
      },
      { status: 200 },
    );
  } catch (error) {
    const responseTime = Date.now() - startTime;
    logger.error('Webhook fatal error:', error);
    return new Response(`Error handled: ${responseTime}ms`, { status: 200 });
  }
}

// üìÑ ÈùûÂêåÊúü„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂá¶ÁêÜ
async function processWebhookEventAsync(event: Stripe.Event) {
  const processingStart = Date.now();

  try {
    logger.info(`Background processing started for: ${event.type}`);

    switch (event.type) {
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;
      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
        break;
      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
        break;
      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;
      case 'charge.dispute.created':
        await handleChargeDispute(event.data.object as Stripe.Dispute);
        break;
      default:
        logger.info(`Unhandled event type: ${event.type}`);
    }

    const processingTime = Date.now() - processingStart;
    logger.info(`Background processing completed for ${event.type} in ${processingTime}ms`);
  } catch (error) {
    const processingTime = Date.now() - processingStart;
    logger.error(
      `Background processing failed for ${event.type} after ${processingTime}ms:`,
      error,
    );
  }
}

// üîß „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥‰ΩúÊàê„Éè„É≥„Éâ„É©„Éº
async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  try {
    const customerId = subscription.customer as string;
    logger.info(`Processing subscription created: ${subscription.id} for customer: ${customerId}`);

    const user = await prisma.user.findFirst({
      where: { stripeCustomerId: customerId },
    });

    if (!user) {
      logger.error(`User not found for customer: ${customerId}`);
      return;
    }

    const priceId = subscription.items.data[0].price.id;
    const planInfo = getPlanInfoByPriceId(priceId);

    if (!planInfo) {
      logger.error(`Plan info not found for price: ${priceId}`);
      return;
    }

    logger.info(`Plan info: ${planInfo.planId}, corporate: ${planInfo.isCorporate}`);

    const subscriptionData = {
      status: subscription.status,
      subscriptionId: subscription.id,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      trialStart: subscription.trial_start ? new Date(subscription.trial_start * 1000) : null,
      trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
      priceId: priceId,
      plan: planInfo.interval === 'year' ? `${planInfo.planId}_yearly` : planInfo.planId,
      interval: planInfo.interval,
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000) : null,
    };

    const result = await prisma.$transaction(async (tx: any) => {
      const upsertedSubscription = await tx.subscription.upsert({
        where: { userId: user.id },
        update: subscriptionData,
        create: {
          userId: user.id,
          ...subscriptionData,
        },
      });

      await tx.user.update({
        where: { id: user.id },
        data: {
          subscriptionStatus: 'active',
          trialEndsAt: null, // ÊúâÊñô„Éó„É©„É≥ÈñãÂßã„Åß„Éà„É©„Ç§„Ç¢„É´ÁµÇ‰∫Ü
          corporateRole: planInfo.isCorporate ? 'admin' : null,
        },
      });

      return upsertedSubscription;
    });

    if (planInfo.isCorporate) {
      try {
        await handleCorporateTenantCreation(user.id, result.id, planInfo);
      } catch (corporateError) {
        logger.warn('Corporate tenant creation failed:', corporateError);
      }
    }

    logger.info(`Subscription creation completed for: ${subscription.id}`);
  } catch (error) {
    logger.error('Subscription creation failed:', error);
    throw error;
  }
}

// üè¢ Ê≥ï‰∫∫„ÉÜ„Éä„É≥„Éà‰ΩúÊàê
async function handleCorporateTenantCreation(
  userId: string,
  subscriptionId: string,
  planInfo: any,
) {
  logger.info('Creating corporate tenant...');

  const existingTenant = await prisma.corporateTenant.findUnique({
    where: { adminId: userId },
  });

  if (existingTenant) {
    logger.info(`Updating existing corporate tenant: ${existingTenant.id}`);
    await prisma.corporateTenant.update({
      where: { id: existingTenant.id },
      data: {
        subscriptionId: subscriptionId,
        maxUsers: planInfo.maxUsers || 10,
      },
    });
  } else {
    logger.info('Creating new corporate tenant');
    const user = await prisma.user.findUnique({ where: { id: userId } });

    const newTenant = await prisma.corporateTenant.create({
      data: {
        name: user?.company || '',
        maxUsers: planInfo.maxUsers || 10,
        adminId: userId,
        subscriptionId: subscriptionId,
        users: { connect: [{ id: userId }] },
        primaryColor: '#3B82F6',
        secondaryColor: 'var(--color-corporate-secondary)',
      },
    });
    logger.info(`Corporate tenant created: ${newTenant.id}`);
  }
}

// üìÑ „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Êõ¥Êñ∞„Éè„É≥„Éâ„É©„Éº
async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  try {
    logger.info(`Processing subscription updated: ${subscription.id}`);

    const customerId = subscription.customer as string;
    const user = await prisma.user.findFirst({
      where: { stripeCustomerId: customerId },
    });

    if (!user) {
      logger.error(`User not found for customer: ${customerId}`);
      return;
    }

    const priceId = subscription.items.data[0].price.id;
    const planInfo = getPlanInfoByPriceId(priceId);

    if (!planInfo) {
      logger.error(`Plan info not found for price: ${priceId}`);
      return;
    }

    const subscriptionData = {
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      trialStart: subscription.trial_start ? new Date(subscription.trial_start * 1000) : null,
      trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
      priceId: priceId,
      plan: planInfo.interval === 'year' ? `${planInfo.planId}_yearly` : planInfo.planId,
      interval: planInfo.interval,
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000) : null,
    };

    await prisma.subscription.update({
      where: { userId: user.id },
      data: subscriptionData,
    });

    logger.info(`Subscription updated for user: ${user.id}`);
  } catch (error) {
    logger.error('Subscription update failed:', error);
  }
}

// üóëÔ∏è „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÂâäÈô§„Éè„É≥„Éâ„É©„Éº
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  try {
    logger.info(`Processing subscription deleted: ${subscription.id}`);

    const customerId = subscription.customer as string;
    const user = await prisma.user.findFirst({
      where: { stripeCustomerId: customerId },
    });

    if (!user) {
      logger.error(`User not found for customer: ${customerId}`);
      return;
    }

    await prisma.$transaction(async (tx: any) => {
      await tx.subscription.update({
        where: { userId: user.id },
        data: {
          status: 'canceled',
          canceledAt: new Date(),
        },
      });

      await tx.user.update({
        where: { id: user.id },
        data: {
          subscriptionStatus: 'canceled',
          corporateRole: null,
        },
      });
    });

    logger.info(`Subscription deletion processed for user: ${user.id}`);
  } catch (error) {
    logger.error('Subscription deletion failed:', error);
  }
}

// üí∞ ÊîØÊâï„ÅÑÊàêÂäü„Éè„É≥„Éâ„É©„Éº
async function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {
  try {
    logger.info(`Processing payment succeeded: ${invoice.id}`);

    if (invoice.subscription) {
      const customerId = invoice.customer as string;
      const user = await prisma.user.findFirst({
        where: { stripeCustomerId: customerId },
      });

      if (user) {
        await prisma.user.update({
          where: { id: user.id },
          data: { subscriptionStatus: 'active' },
        });

        // Ë≤°Âãô„Éá„Éº„Çø„ÅÆË®òÈå≤
        if (invoice.payment_intent) {
          try {
            await recordFinancialDataFromInvoice(invoice, user);
          } catch (financialError) {
            logger.warn('Financial data recording failed:', financialError);
          }
        }

        logger.info(`Payment success processed for user: ${user.id}`);
      }
    }
  } catch (error) {
    logger.error('Payment success handling failed:', error);
  }
}

// ‚ùå ÊîØÊâï„ÅÑÂ§±Êïó„Éè„É≥„Éâ„É©„Éº
async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  try {
    logger.info(`Processing payment failed: ${invoice.id}`);

    if (invoice.subscription) {
      const customerId = invoice.customer as string;
      const user = await prisma.user.findFirst({
        where: { stripeCustomerId: customerId },
      });

      if (user) {
        await prisma.user.update({
          where: { id: user.id },
          data: { subscriptionStatus: 'past_due' },
        });
        logger.warn(`Payment failure processed for user: ${user.id}`);
      }
    }
  } catch (error) {
    logger.error('Payment failure handling failed:', error);
  }
}

// üõí „ÉÅ„Çß„ÉÉ„ÇØ„Ç¢„Ç¶„ÉàÂÆå‰∫Ü„Éè„É≥„Éâ„É©„Éº
async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  try {
    logger.info(`Processing checkout completed: ${session.id}`);

    const customerId = session.customer as string;
    const user = await prisma.user.findFirst({
      where: { stripeCustomerId: customerId },
    });

    if (!user) {
      logger.error(`User not found for customer: ${customerId}`);
      return;
    }

    // „É°„Çø„Éá„Éº„Çø„Åã„ÇâÊ±∫Ê∏à„Çø„Ç§„Éó„ÇíÁ¢∫Ë™ç
    const subscriptionType = session.metadata?.subscriptionType || 'standard';
    const hasOneTapSealOrder = session.metadata?.oneTapSealOrder === 'true';
    const plan = session.metadata?.plan;
    const interval = session.metadata?.interval || 'month';
    const isCorporate = session.metadata?.isCorporate === 'true';

    logger.info(`Checkout type: ${subscriptionType}, OneTapSeal: ${hasOneTapSealOrder}`);

    await prisma.$transaction(async (tx: any) => {
      // üÜï „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´ÂçòÁã¨Ê±∫Ê∏à„ÅÆÂ†¥Âêà
      if (subscriptionType === 'one_tap_seal_only') {
        logger.info('Processing OneTapSeal-only checkout');

        // „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá„ÅÆÁä∂ÊÖãÊõ¥Êñ∞
        const orderId = session.metadata?.orderId;
        if (orderId) {
          const order = await tx.oneTapSealOrder.findUnique({
            where: { id: orderId },
          });

          if (order) {
            await tx.oneTapSealOrder.update({
              where: { id: orderId },
              data: {
                status: 'paid',
                stripePaymentIntentId: session.payment_intent as string,
              },
            });

            logger.info(`OneTapSeal order updated to paid: ${orderId}`);
          } else {
            logger.warn(`OneTapSeal order not found: ${orderId}`);
          }
        }

        // „É¶„Éº„Ç∂„ÉºÁä∂ÊÖã„ÅØÊõ¥Êñ∞„Åó„Å™„ÅÑÔºà„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´ÂçòÁã¨Ë≥ºÂÖ•„ÅÆ„Åü„ÇÅÔºâ
        logger.info(`OneTapSeal-only checkout completed for user: ${user.id}`);
        return;
      }
      
      // 1. „É¶„Éº„Ç∂„ÉºÁä∂ÊÖãÊõ¥Êñ∞
      await tx.user.update({
        where: { id: user.id },
        data: {
          subscriptionStatus: 'active',
          trialEndsAt: null, // ÊúâÊñô„Éó„É©„É≥ÈñãÂßã„Åß„Éà„É©„Ç§„Ç¢„É´ÁµÇ‰∫Ü
          corporateRole: isCorporate ? 'admin' : null,
        },
      });

      // 2. ‰∏ÄÂõûÈôê„ÇäÊ±∫Ê∏à„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíÊâãÂãï‰ΩúÊàê
      if (subscriptionType === 'plan_with_onetap' || !session.subscription) {
        logger.info('Creating subscription manually for one-time payment');

        // Êó¢Â≠ò„ÅÆpending„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíÊ§úÁ¥¢„ÉªÊõ¥Êñ∞
        const existingSubscription = await tx.subscription.findFirst({
          where: {
            userId: user.id,
            subscriptionId: session.id, // Checkout Session ID„ÅßÊ§úÁ¥¢
            status: 'pending',
          },
        });

        if (existingSubscription) {
          // Stripe„Åß„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Çí‰ΩúÊàê
          let stripeSubscription = null;

          if (plan && stripe) {
            try {
              const planInfo = getPaymentLinkByPlan(plan, interval);

              if (planInfo && planInfo.priceId) {
                stripeSubscription = await stripe.subscriptions.create({
                  customer: customerId,
                  items: [{ price: planInfo.priceId }],
                  metadata: {
                    userId: user.id,
                    plan: plan,
                    interval: interval,
                    createdViaCheckout: 'true',
                  },
                });

                logger.info(`Stripe subscription created: ${stripeSubscription.id}`);
              }
            } catch (stripeError) {
              logger.error('Failed to create Stripe subscription:', stripeError);
            }
          }

          // „É≠„Éº„Ç´„É´„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Êõ¥Êñ∞
          await tx.subscription.update({
            where: { id: existingSubscription.id },
            data: {
              status: 'active',
              subscriptionId: stripeSubscription?.id || `manual_${session.id}`,
              currentPeriodStart: new Date(),
              currentPeriodEnd: new Date(
                Date.now() + (interval === 'year' ? 365 : 30) * 24 * 60 * 60 * 1000,
              ),
            },
          });

          logger.info(`Subscription updated: ${existingSubscription.id}`);
        }
      }
      // 3. ÈÄöÂ∏∏„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Ê±∫Ê∏à„ÅÆÂ†¥Âêà
      else if (session.subscription) {
        await tx.subscription.updateMany({
          where: {
            userId: user.id,
            subscriptionId: session.id,
          },
          data: {
            status: 'active',
            subscriptionId: session.subscription as string,
          },
        });
      }

      // 4. „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá„ÅÆÁä∂ÊÖãÊõ¥Êñ∞
      if (hasOneTapSealOrder) {
        logger.info(`Processing OneTapSeal order for checkout: ${session.id}`);

        const oneTapSealOrder = await tx.oneTapSealOrder.findFirst({
          where: {
            userId: user.id,
            stripePaymentIntentId: session.id,
            status: 'pending',
          },
        });

        if (oneTapSealOrder) {
          await tx.oneTapSealOrder.update({
            where: { id: oneTapSealOrder.id },
            data: {
              status: 'paid',
              stripePaymentIntentId: session.payment_intent as string,
            },
          });

          logger.info(`OneTapSeal order updated to paid: ${oneTapSealOrder.id}`);
        } else {
          logger.warn(`OneTapSeal order not found for checkout: ${session.id}`);
        }
      }
    });

    logger.info(
      `Checkout completion processed for user: ${user.id}, Type: ${subscriptionType}, OneTapSeal: ${hasOneTapSealOrder}`,
    );
  } catch (error) {
    logger.error('Checkout completion failed:', error);
  }
}

// PaymentIntent„Çµ„ÇØ„Çª„Çπ„Éè„É≥„Éâ„É©„Éº
async function handlePaymentIntentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  try {
    logger.info(`Processing PaymentIntent succeeded: ${paymentIntent.id}`);

    const user = await prisma.user.findFirst({
      where: { stripeCustomerId: paymentIntent.customer as string },
    });

    if (!user) {
      logger.info(`User not found for PaymentIntent: ${paymentIntent.id}`);
      return;
    }

    await prisma.$transaction(async (tx: any) => {
      // Ë≤°Âãô„Éá„Éº„ÇøË®òÈå≤
      await recordFinancialDataFromPaymentIntent(paymentIntent, user, tx);

      // „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá„ÅÆÊúÄÁµÇÁ¢∫Ë™ç„ÉªÊõ¥Êñ∞
      const oneTapSealOrder = await tx.oneTapSealOrder.findFirst({
        where: {
          userId: user.id,
          stripePaymentIntentId: paymentIntent.id,
          status: 'paid',
        },
      });

      if (oneTapSealOrder) {
        logger.info(`Confirmed OneTapSeal order payment: ${oneTapSealOrder.id}`);

        await tx.oneTapSealOrder.update({
          where: { id: oneTapSealOrder.id },
          data: {
            status: 'preparing',
          },
        });

        logger.info(`OneTapSeal order status updated to preparing: ${oneTapSealOrder.id}`);
      }
    });

    logger.info(`PaymentIntent financial data recorded: ${paymentIntent.id}`);
  } catch (error) {
    logger.error('PaymentIntent processing failed:', error);
  }
}

// „ÉÅ„É£„Éº„Ç∏„Éê„ÉÉ„ÇØÂá¶ÁêÜ„Éè„É≥„Éâ„É©„Éº
async function handleChargeDispute(dispute: Stripe.Dispute) {
  try {
    logger.info(`Processing charge dispute: ${dispute.id}`);

    const transaction = await prisma.stripeTransaction.findUnique({
      where: { stripeChargeId: dispute.charge as string },
    });

    if (transaction) {
      await prisma.stripeTransaction.update({
        where: { id: transaction.id },
        data: {
          status: 'disputed',
          refundReason: `„ÉÅ„É£„Éº„Ç∏„Éê„ÉÉ„ÇØ: ${dispute.reason}`,
        },
      });

      logger.info(`Dispute recorded for transaction: ${transaction.id}`);
    }
  } catch (error) {
    logger.error('Dispute processing failed:', error);
  }
}

// üí∞ Ë´ãÊ±ÇÊõ∏„Åã„ÇâË≤°Âãô„Éá„Éº„Çø„ÇíË®òÈå≤
async function recordFinancialDataFromInvoice(invoice: Stripe.Invoice, user: any) {
  try {
    logger.info('Recording financial data from invoice:', invoice.id);

    const stripeClient = getStripeInstance();
    const paymentIntent = await stripeClient.paymentIntents.retrieve(
      invoice.payment_intent as string,
    );

    if (paymentIntent.status === 'succeeded') {
      await recordFinancialDataFromPaymentIntent(paymentIntent, user);
    }
  } catch (error) {
    logger.error('Failed to record financial data from invoice:', error);
    throw error;
  }
}

// üí≥ PaymentIntent„Åã„ÇâË≤°Âãô„Éá„Éº„Çø„ÇíË®òÈå≤Ôºà„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´ÂØæÂøúÔºâ
async function recordFinancialDataFromPaymentIntent(
  paymentIntent: Stripe.PaymentIntent,
  user: any,
  tx?: any,
) {
  try {
    logger.info('Recording financial data from PaymentIntent:', paymentIntent.id);

    const stripeClient = getStripeInstance();
    const charges = await stripeClient.charges.list({
      payment_intent: paymentIntent.id,
      limit: 1,
    });

    const charge = charges.data[0];
    if (!charge?.balance_transaction) {
      logger.info('No balance transaction found, skipping financial record');
      return;
    }

    const balanceTransaction = await stripeClient.balanceTransactions.retrieve(
      charge.balance_transaction as string,
    );

    const amount = paymentIntent.amount / 100;
    const feeAmount = balanceTransaction.fee / 100;
    const netAmount = balanceTransaction.net / 100;

    // „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®ÊñáÊÉÖÂ†±„ÅÆÁ¢∫Ë™ç
    const isOneTapSealOrder = paymentIntent.metadata?.orderType === 'one_tap_seal';
    const planInfo = extractPlanInfoFromPaymentIntent(paymentIntent);

    const transactionProcessor = tx || prisma;

    // Ë≤°Âãô„Éá„Éº„Çø„Çí„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÅßË®òÈå≤
    const financialOperation = async (transaction: any) => {
      // 1. StripeTransaction„É¨„Ç≥„Éº„Éâ‰ΩúÊàê
      const stripeTransaction = await transaction.stripeTransaction.create({
        data: {
          stripePaymentId: paymentIntent.id,
          stripeChargeId: charge.id,
          stripeCustomerId: (paymentIntent.customer as string) || null,
          amount: amount,
          currency: paymentIntent.currency,
          description: paymentIntent.description || 'ÂÆöÊúüÊîØÊâï„ÅÑ',
          customerEmail: charge.billing_details?.email || user.email,
          stripeFeeAmount: feeAmount,
          stripeFeeRate: amount > 0 ? feeAmount / amount : 0,
          netAmount: netAmount,
          transactionDate: new Date(paymentIntent.created * 1000),
          subscriptionType: planInfo.planId || 'unknown',
          planName: planInfo.displayName || null,
          status: 'succeeded',
          stripeMetadata: paymentIntent.metadata as any,
          webhookProcessed: true,
        },
      });

      // 2. FinancialRecord„É¨„Ç≥„Éº„Éâ‰ΩúÊàêÔºàÁµ±ÂêàÁÆ°ÁêÜÁî®Ôºâ
      await transaction.financialRecord.create({
        data: {
          recordType: isOneTapSealOrder ? 'one_tap_seal_revenue' : 'stripe_revenue',
          title: `Â£≤‰∏ä: ${paymentIntent.description || 'StripeÊ±∫Ê∏à'}`,
          description: `„Éó„É©„É≥: ${planInfo.displayName || '‰∏çÊòé'}${isOneTapSealOrder ? ' + „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´' : ''}`,
          amount: amount,
          category: planInfo.planId || 'subscription',
          recordDate: new Date(paymentIntent.created * 1000),
          sourceType: 'stripe',
          sourceId: paymentIntent.id,
          isAutoImported: true,
          feeAmount: feeAmount,
          netAmount: netAmount,
          inputBy: 'system',
          createdBy: 'system',
          type: 'revenue',
          date: new Date(paymentIntent.created * 1000),
          needsApproval: false,
          approvalStatus: 'approved',
          financialRecordId: stripeTransaction.id,
        },
      });

      logger.info('Financial data recorded:', {
        transactionId: stripeTransaction.id,
        amount: amount,
        fees: feeAmount,
        net: netAmount,
        isOneTapSeal: isOneTapSealOrder,
      });
    };

    if (tx) {
      await financialOperation(tx);
    } else {
      await prisma.$transaction(financialOperation);
    }
  } catch (error) {
    logger.error('Failed to record financial data from PaymentIntent:', error);
    throw error;
  }
}

// „Éó„É©„É≥ÊÉÖÂ†±„ÇíPaymentIntent„Åã„ÇâÊé®ÂÆöÔºà„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´+„Éó„É©„É≥ÂêåÊôÇÊ±∫Ê∏àÂØæÂøúÔºâ
function extractPlanInfoFromPaymentIntent(paymentIntent: Stripe.PaymentIntent) {
  // „É°„Çø„Éá„Éº„Çø„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
  if (paymentIntent.metadata?.subscription_type) {
    return {
      planId: paymentIntent.metadata.subscription_type,
      displayName: paymentIntent.metadata.plan_name || paymentIntent.metadata.subscription_type,
    };
  }

  // ÂêåÊôÇÊ±∫Ê∏à„ÅÆÂ†¥Âêà„ÅÆ„É°„Çø„Éá„Éº„ÇøÂá¶ÁêÜ
  if (paymentIntent.metadata?.subscriptionType === 'plan_with_onetap') {
    const plan = paymentIntent.metadata.plan;
    const interval = paymentIntent.metadata.interval || 'month';

    return {
      planId: plan || 'unknown',
      displayName: `${plan}„Éó„É©„É≥Ôºà${interval === 'year' ? 'Âπ¥È°ç' : 'ÊúàÈ°ç'}Ôºâ+ „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´`,
    };
  }

  // „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá„ÅÆÂ†¥Âêà
  if (paymentIntent.metadata?.orderType === 'one_tap_seal') {
    return {
      planId: 'one_tap_seal',
      displayName: '„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá',
    };
  }

  // Ë™¨ÊòéÊñá„Åã„ÇâÊé®ÂÆö
  const description = paymentIntent.description || '';
  const planPatterns = [
    { pattern: /ÂÄã‰∫∫.*ÊúàÈ°ç/i, planId: 'monthly', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ' },
    { pattern: /ÂÄã‰∫∫.*Âπ¥È°ç/i, planId: 'yearly', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ' },
    { pattern: /Ê≥ï‰∫∫.*„Çπ„Çø„Éº„Çø„Éº/i, planId: 'starter', displayName: 'Ê≥ï‰∫∫„Çπ„Çø„Éº„Çø„Éº„Éó„É©„É≥' },
    { pattern: /Ê≥ï‰∫∫.*„Éì„Ç∏„Éç„Çπ/i, planId: 'business', displayName: 'Ê≥ï‰∫∫„Éì„Ç∏„Éç„Çπ„Éó„É©„É≥' },
    {
      pattern: /Ê≥ï‰∫∫.*„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫/i,
      planId: 'enterprise',
      displayName: 'Ê≥ï‰∫∫„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫„Éó„É©„É≥',
    },
    { pattern: /„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´/i, planId: 'one_tap_seal', displayName: '„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá' },
  ];

  for (const { pattern, planId, displayName } of planPatterns) {
    if (pattern.test(description)) {
      return { planId, displayName };
    }
  }

  // ÈáëÈ°ç„Åã„ÇâÊé®ÂÆöÔºàÂêåÊôÇÊ±∫Ê∏à„ÅÆÂ†¥Âêà„ÅÆË§áÂêàÈáëÈ°çÂØæÂøúÔºâ
  const amount = paymentIntent.amount / 100;

  // Âçò‰Ωì„Éó„É©„É≥ÈáëÈ°ç
  if (amount === 550) return { planId: 'monthly', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ' };
  if (amount === 5500) return { planId: 'yearly', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ' };
  if (amount === 3300) return { planId: 'starter', displayName: 'Ê≥ï‰∫∫„Çπ„Çø„Éº„Çø„Éº„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ' };
  if (amount === 33000) return { planId: 'starter', displayName: 'Ê≥ï‰∫∫„Çπ„Çø„Éº„Çø„Éº„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ' };
  if (amount === 6600) return { planId: 'business', displayName: 'Ê≥ï‰∫∫„Éì„Ç∏„Éç„Çπ„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ' };
  if (amount === 66000) return { planId: 'business', displayName: 'Ê≥ï‰∫∫„Éì„Ç∏„Éç„Çπ„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ' };
  if (amount === 9900)
    return { planId: 'enterprise', displayName: 'Ê≥ï‰∫∫„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ' };
  if (amount === 99000)
    return { planId: 'enterprise', displayName: 'Ê≥ï‰∫∫„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ' };

  // „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Âçò‰Ωì‰æ°Ê†ºÂ∏Ø„ÅÆÊé®ÂÆö
  if (amount >= 735 && amount <= 5685) {
    return { planId: 'one_tap_seal', displayName: '„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´Ê≥®Êñá' };
  }

  // „Éó„É©„É≥+„ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´ÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÊé®ÂÆö
  if (amount >= 1285 && amount <= 6235) {
    const sealAmount = amount - 550;
    if (sealAmount >= 735 && sealAmount <= 5685) {
      return { planId: 'monthly_with_seal', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ+ „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´' };
    }
  }

  if (amount >= 6235 && amount <= 11185) {
    const sealAmount = amount - 5500;
    if (sealAmount >= 735 && sealAmount <= 5685) {
      return { planId: 'yearly_with_seal', displayName: 'ÂÄã‰∫∫„Éó„É©„É≥ÔºàÂπ¥È°çÔºâ+ „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´' };
    }
  }

  if (amount >= 4035 && amount <= 8985) {
    const sealAmount = amount - 3300;
    if (sealAmount >= 735 && sealAmount <= 5685) {
      return {
        planId: 'starter_with_seal',
        displayName: 'Ê≥ï‰∫∫„Çπ„Çø„Éº„Çø„Éº„Éó„É©„É≥ÔºàÊúàÈ°çÔºâ+ „ÉØ„É≥„Çø„ÉÉ„Éó„Ç∑„Éº„É´',
      };
    }
  }

  return { planId: 'unknown', displayName: '‰∏çÊòé„Å™„Éó„É©„É≥' };
}