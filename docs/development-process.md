# Share開発プロセスと協業ルール

## 1. 開発スタイルと方針

### 1.1 開発哲学
- **シンプルさ優先**: 過度な複雑さを避け、シンプルな解決策を優先する
- **段階的実装**: 最小機能から始め、段階的に拡張していく
- **品質重視**: 速度よりも品質を優先する
- **一貫性**: コード、設計、UI/UXにおいて一貫性を保つ
- **ユーザー中心**: すべての意思決定はエンドユーザーの体験向上を基準に行う

### 1.2 個人開発者としてのアプローチ
- **時間管理**: 一度に取り組むタスクを限定し、集中して実装する
- **知識の文書化**: 調査結果や決定事項を継続的に文書化する
- **休息と健康**: 持続可能な開発ペースを維持するために定期的な休息を確保する
- **フィードバックの活用**: 早期からユーザーフィードバックを収集し活用する
- **優先順位付け**: MVP完成に不可欠な機能に集中し、「あったら良い」機能は後回しにする

### 1.3 AI協業のアプローチ
- **強みの活用**: Claudeの強みを活かす（コード生成、問題解決、設計レビュー）
- **ポモドーロ技法**: 25分の集中作業と5分の休憩を組み合わせ、適度にClaudeとの協業セッションを行う
- **反復的改善**: 生成されたコードを理解し、必要に応じて改善する
- **自立性**: AIに依存しすぎず、最終決定は開発者が行う

## 2. Claude協業ルール

### 2.1 協業セッションの構造

#### 2.1.1 セッション開始テンプレート
```
プロジェクト: ShareSNSシェアサービス
現在のフェーズ: [現在のフェーズ名]
前回のセッション要約: [前回セッションの決定事項や進捗]
今回の目標: [今回のセッションで達成したいこと]
関連ドキュメント: [参照すべき設計書やコードへのリンク]
質問/タスク: [具体的な質問や依頼内容]
```

#### 2.1.2 セッション終了プロンプト
```
以上で今回のセッションを終了します。今回の主要な決定事項と次のステップをまとめてください。
```

### 2.2 一貫性を保つためのルール

#### 2.2.1 ドキュメント参照
- 各セッションで関連する設計ドキュメントを明示的に参照する
- 設計から逸脱する場合は理由を明記し、設計ドキュメントを更新する

#### 2.2.2 コンテキスト維持
- セッション開始時に前回の要約を含める
- 長期間が空いた場合は、より詳細なプロジェクト状況のレビューを行う

#### 2.2.3 決定事項の記録
- 重要な決定事項は必ず文書化する
- 設計変更があった場合は設計ドキュメントを更新する

#### 2.2.4 共通言語の使用
- 技術用語や命名は一貫して使用する
- プロジェクト固有の用語集を維持する

### 2.3 コード生成のルール

#### 2.3.1 コードスタイル
- TypeScriptの型を適切に活用する
- ESLintとPrettierの設定に従う
- 関数型プログラミングのアプローチを優先する
- 可読性の高いコードを心がける

#### 2.3.2 命名規則
- **コンポーネント**: PascalCase (例: `ProfileCard`)
- **関数**: camelCase (例: `fetchUserData`)
- **変数**: camelCase (例: `userData`)
- **定数**: UPPER_SNAKE_CASE (例: `API_BASE_URL`)
- **ファイル名**: 
  - コンポーネント: PascalCase (例: `ProfileCard.tsx`)
  - ユーティリティ: camelCase (例: `formatDate.ts`)
- **CSS**: kebab-case (例: `profile-container`)

#### 2.3.3 コード品質
- 単一責任の原則を守る
- 冗長なコードを避ける
- エラーハンドリングを適切に行う
- コメントは「なぜ」を説明するために使用する

### 2.4 問題解決のアプローチ

#### 2.4.1 問題定義
- 問題を明確に定義し、範囲を限定する
- 関連する制約条件を明示する

#### 2.4.2 解決策の提案
- 複数の解決策を提案し、それぞれの長所と短所を説明する
- プロジェクトの原則と一貫性に基づいて最適な解決策を選択する

#### 2.4.3 実装ガイダンス
- ステップバイステップのアプローチを提供する
- 必要に応じてサンプルコードや疑似コードを提供する

## 3. 開発ワークフロー

### 3.1 タスク管理

#### 3.1.1 タスクの構造
- **エピック**: 大きな機能単位（例: 「認証システム」「プロフィール管理」）
- **ストーリー**: ユーザーストーリー単位のタスク
- **タスク**: 具体的な実装単位（2-4時間で完了できるサイズ）
- **サブタスク**: 必要に応じてさらに細分化

#### 3.1.2 タスク管理ツール
- **GitHub Projects**: タスクボードとイシュー管理
- **開発ログ**: 日々の進捗と問題点を記録するドキュメント

#### 3.1.3 タスク状態
- **Backlog**: 未着手のタスク
- **Next Up**: 次に取り組む予定のタスク
- **In Progress**: 現在作業中のタスク
- **Review**: レビュー待ちのタスク
- **Done**: 完了したタスク

### 3.2 開発サイクル

#### 3.2.1 週次サイクル
- **月曜日**: 週間計画の作成とタスクの優先順位付け
- **火-木曜日**: 実装作業
- **金曜日**: 週の振り返りと次週の準備

#### 3.2.2 デイリールーチン
- **朝**: 今日の目標設定（15分）
- **日中**: 実装作業（ポモドーロ技法を活用）
- **夕方**: 今日の振り返りと明日の準備（15分）

#### 3.2.3 タスク取り組み方
1. タスクを選択し、明確な目標を設定
2. 必要に応じてClaudeと協業セッションを開始
3. 実装
4. 自己レビュー
5. （必要に応じて）Claudeにレビュー依頼
6. タスク完了の記録

### 3.3 コードバージョン管理

#### 3.3.1 ブランチ戦略
- **main**: 安定版コード
- **develop**: 開発中のコード
- **feature/[機能名]**: 個別機能の開発ブランチ
- **fix/[問題名]**: バグ修正用ブランチ

#### 3.3.2 コミットルール
- 意味のある単位でコミット
- コミットメッセージは英語で簡潔に内容を説明
- プレフィックスを使用（例: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`）

#### 3.3.3 プルリクエスト
- 自分自身へのプルリクエストとして実装をレビュー
- 変更内容と影響範囲を明記
- Claudeの支援を得てレビュー

## 4. 品質保証プロセス

### 4.1 コードレビュー

#### 4.1.1 セルフレビュー
- コードの一貫性と品質を確認
- 機能テスト
- エッジケースの考慮

#### 4.1.2 AI支援レビュー
- Claudeを活用したコードレビュー
- セキュリティ、パフォーマンス、ベストプラクティスの観点からのフィードバック

### 4.2 テスト戦略

#### 4.2.1 手動テスト
- ユーザーストーリーに基づいたシナリオテスト
- 異なるデバイスとブラウザでの動作確認
- エラーケースのテスト

#### 4.2.2 自動テスト
- 重要なユーティリティと関数の単体テスト
- コアコンポーネントのテスト
- 主要ユーザーフローのE2Eテスト（後期フェーズ）

### 4.3 デプロイプロセス

#### 4.3.1 開発環境
- ローカル開発サーバー
- Vercelプレビュー環境

#### 4.3.2 ステージング
- develop ブランチの自動デプロイ
- 機能テストと検証

#### 4.3.3 本番環境
- main ブランチからの手動デプロイ
- デプロイ前チェックリストの確認

## 5. ドキュメント管理

### 5.1 ドキュメントの種類

#### 5.1.1 プロジェクト文書
- プロジェクト概要
- 要件定義
- 技術設計
- 開発プロセス

#### 5.1.2 技術文書
- アーキテクチャ図
- データモデル
- API仕様
- コンポーネント一覧

#### 5.1.3 操作マニュアル
- インストールガイド
- 管理者マニュアル
- ユーザーガイド

### 5.2 ドキュメント更新プロセス

#### 5.2.1 更新トリガー
- 設計変更時
- 重要な実装判断時
- バグ修正から得られた教訓時
- 新機能追加時

#### 5.2.2 更新手順
1. 変更が必要なドキュメントの特定
2. 変更内容の草案作成
3. ドキュメントの更新
4. 変更内容のサマリーを更新履歴に追加

### 5.3 ナレッジベース

#### 5.3.1 開発者ノート
- トラブルシューティングのメモ
- 設計判断の背景
- 参考リソース

#### 5.3.2 よくある問題と解決策
- 遭遇した問題と解決方法のカタログ
- 回避策とベストプラクティス

## 6. コミュニケーション規約

### 6.1 Claude協業セッションのルール

#### 6.1.1 明確なリクエスト
- 一度に一つのトピックに集中
- 具体的で明確な質問や依頼
- 必要な背景情報の提供

#### 6.1.2 フィードバックと反復
- 生成されたコードや提案に対する明確なフィードバック
- 必要に応じて調整を依頼
- 理解できない場合は遠慮なく質問

### 6.2 議論と決定のプロセス

#### 6.2.1 意思決定フレームワーク
1. 問題または決定事項の明確化
2. 選択肢の列挙（少なくとも2つ）
3. 各選択肢のメリット・デメリットの評価
4. プロジェクト原則に基づく判断
5. 決定事項の文書化

#### 6.2.2 優先順位付け
- **Must Have**: MVPに不可欠
- **Should Have**: 重要だが延期可能
- **Could Have**: あれば良いが必須ではない
- **Won't Have**: 現段階では実装しない

### 6.3 プロジェクトの健全性維持

#### 6.3.1 定期的な振り返り
- 週次の進捗レビュー
- 月次のプロジェクト健全性チェック

#### 6.3.2 メンタルヘルスと持続可能性
- 過労を避けるための作業時間管理
- 定期的な休息と気分転換
- ストレスや行き詰まりを感じたら早めに認識し対処

## 7. リソース管理

### 7.1 時間管理

#### 7.1.1 時間配分ガイドライン
- **コア開発**: 全体の60%（設計、コーディング、テスト）
- **学習と調査**: 20%（新技術や解決策の調査）
- **レビューと改善**: 15%（コードレビュー、リファクタリング）
- **ドキュメント**: 5%（文書化と記録）

#### 7.1.2 時間追跡
- 日々の作業ログの記録
- 作業タイプごとの時間計測
- 定期的な時間使用分析

### 7.2 技術的負債の管理

#### 7.2.1 負債の識別
- コメントでの「TODO」、「FIXME」マーキング
- 技術的負債のイシュー作成

#### 7.2.2 負債の返済計画
- 各スプリントで一定時間を技術的負債の解消に充てる
- リファクタリングを計画的に実施

### 7.3 外部リソースの活用

#### 7.3.1 オープンソースライブラリ
- 厳選された高品質なライブラリの使用
- 依存関係の最小化

#### 7.3.2 学習リソース
- 公式ドキュメント
- チュートリアルとブログ記事
- コミュニティフォーラム

## 8. 継続的改善

### 8.1 フィードバックループ

#### 8.1.1 フィードバック収集
- ユーザーからのフィードバック
- 自己評価
- AI支援からの洞察

#### 8.1.2 改善プロセス
1. フィードバックの分析
2. 改善機会の特定
3. 改善案の策定
4. 実装と評価

### 8.2 スキル向上

#### 8.2.1 技術スキル
- Next.js、React、TypeScript、Tailwind CSSの深耕
- バックエンド技術の強化
- パフォーマンス最適化技術の習得

#### 8.2.2 ツール活用スキル
- AIツールの効果的な利用法の習得
- 開発効率化ツールの探求

### 8.3 プロセス改善

#### 8.3.1 効率化の追求
- 反復作業の自動化
- ボトルネックの特定と解消

#### 8.3.2 プロセス評価
- 月次のプロセスレビュー
- 改善点の文書化と実装

## 9. 危機管理

### 9.1 リスク管理

#### 9.1.1 リスク識別
- 技術的リスク
- スケジュールリスク
- 品質リスク
- 外部依存のリスク

#### 9.1.2 リスク軽減策
- 主要リスクに対する対応計画
- 早期警戒指標の設定

### 9.2 問題解決フレームワーク

#### 9.2.1 問題への対応手順
1. 問題の明確な定義
2. 根本原因の分析
3. 解決策の検討
4. 実行計画の策定と実施
5. 結果の評価と学習

#### 9.2.2 外部支援の活用
- コミュニティフォーラム
- Stack Overflow
- 公式ドキュメント
- AIツールの活用

### 9.3 バックアップと復旧

#### 9.3.1 コードバックアップ
- Gitリポジトリの複数のリモートコピー
- 重要なマイルストーンでのリリースタグ

#### 9.3.2 データバックアップ
- 開発データの定期的なバックアップ
- 設計ドキュメントのバージョン管理

## 10. 協業チェックリスト

### 10.1 セッション開始前チェックリスト
- [ ] 前回のセッションの要約を用意
- [ ] 具体的な目標と質問を明確にする
- [ ] 関連するドキュメントへの参照を準備
- [ ] 現在のプロジェクトフェーズを確認
- [ ] 必要なコードスニペットやエラーメッセージを準備

### 10.2 セッション終了前チェックリスト
- [ ] 主要な決定事項の確認
- [ ] 次のステップの明確化
- [ ] 未解決の質問の特定
- [ ] 文書更新の必要性の確認
- [ ] セッション要約の依頼

### 10.3 実装前チェックリスト
- [ ] 要件と設計の一致を確認
- [ ] 技術的アプローチの妥当性を検証
- [ ] 既存コードとの一貫性を確認
- [ ] エッジケースの考慮
- [ ] 必要なリソース（API、ライブラリなど）の確認

### 10.4 実装後チェックリスト
- [ ] 動作確認（機能テスト）
- [ ] コードスタイルと命名規則の遵守
- [ ] 型の適切な使用
- [ ] エラーハンドリングの完全性
- [ ] パフォーマンス考慮事項の確認
- [ ] ドキュメントの更新